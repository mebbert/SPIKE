/**
 * 
 */
package spike.tools.structuralvariantcaller;

import htsjdk.samtools.ValidationStringency;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;

import net.sourceforge.argparse4j.ArgumentParsers;
import net.sourceforge.argparse4j.inf.ArgumentGroup;
import net.sourceforge.argparse4j.inf.ArgumentParser;
import net.sourceforge.argparse4j.inf.ArgumentParserException;
import net.sourceforge.argparse4j.inf.Namespace;

import org.apache.log4j.Logger;

import spike.Engine;
import spike.tools.utilitybelt.UtilityBelt;

/**
 * @author markebbert
 *
 */
public class StructuralVariantCallerEngine implements Engine {

	private static Logger logger = Logger.getLogger(StructuralVariantCallerEngine.class);
	private static ArgumentParser parser;
	private Namespace parsedArgs;
	
	public StructuralVariantCallerEngine(String[] args) {
		init(args);
	}
	
	/**
	 * Init the parser options
	 * 
	 * @param args
	 */
	private void init(String[] args){
		parser = ArgumentParsers.newArgumentParser("StructuralVariantCaller");
		parser.description("The Structural Variant Caller will identify"
				+ " structural variants using aligned long reads from"
				+ " long-read technologies such as PacBio SMRT or the"
				+ " Oxford Nanopore Technologies' MinIon.");
		parser.defaultHelp(true);
		
		ArgumentGroup ioOptions = parser.addArgumentGroup("input/output arguments");
		ArgumentGroup svcOptions = parser.addArgumentGroup("variant caller arguments");
		
		/* Setup IO options */
		ioOptions
				.addArgument("-i", "--input")
				.dest("SAM")
				.metavar("SAM/BAM")
				.type(String.class)
				.required(true)
				.help("The input file. This can be a SAM or BAM file.");
		
		ioOptions
				.addArgument("-r", "--sample-ref")
				.dest("REF")
				.type(String.class)
				.required(true)
				.help("The sample's reference file. Must also have an associated"
						+ " '.dict' file as generated by Picard's "
						+ " CreateSequenceDictionary.jar");
		
		ioOptions
				.addArgument("-g", "--human-ref")
				.dest("HG_REF")
				.type(String.class)
				.required(true)
				.help("The human genome reference file. Must also have an associated"
						+ " '.dict' file as generated by Picard's "
						+ " CreateSequenceDictionary.jar");

		ioOptions
				.addArgument("-o", "--output")
				.dest("VCF")
				.type(String.class)
				.required(true)
				.help("The output VCF file.");
		
		
		/* Setup SVC options */
		svcOptions
				.addArgument("-s", "--min-structural-variant-size")
				.dest("MIN_SIZE")
				.metavar("SIZE")
				.setDefault(30)
				.type(Integer.class)
				.help("The minimum size structural variant to consider.");

		svcOptions
				.addArgument("-m", "--min-mapping-quality")
				.dest("MinMapQual")
				.metavar("QUAL")
				.setDefault(1)
				.type(Integer.class)
				.help("The minimum mapping quality to consider a given"
						+ " read.");
		
		svcOptions
				.addArgument("-d", "--min-depth")
				.dest("MinDepth")
				.metavar("DEPTH")
				.setDefault(50)
				.type(Integer.class)
				.help("The minimum depth required to identify a structural"
						+ " variant.");
		
		svcOptions
				.addArgument("-e", "--expected-coverage")
				.dest("ExpectedCoverage")
				.metavar("EXPCOV")
				.setDefault(200)
				.type(Integer.class)
				.help("The expected coverage for a given base. Regions"
						+ " with excessive coverage require tender love"
						+ " and care. Excessive coverage originates from"
						+ " reference segments from multiple regions of"
						+ " the genome aligning to the same spot.");
		
		svcOptions
				.addArgument("-c", "--max-clip")
				.dest("CLIP")
				.setDefault(50)
				.type(Integer.class)
				.help("Filter reads that have this many soft-clipped bases,"
						+ " or more. This cannot be too small, or certain"
						+ " variants (insertions, copy gains, inversions)"
						+ " will be missed.");
			
		svcOptions
				.addArgument("-v", "--validation-stringency")
				.dest("STRINGENCY")
				.setDefault("STRICT")
				.choices("STRICT", "LENIENT", "SILENT")
				.type(String.class)
				.help("The validation stringency when parsing a SAM/BAM"
						+ " file. 'STRICT' will throw errors if something "
						+ " is amiss, 'LENIENT' will give warnings but continue,"
						+ " and 'SILENT' will continue AND keep our mouth shut.");
		
		
		
		try{
			parsedArgs = parser.parseArgs(args);
		} catch (ArgumentParserException e){
			parser.handleError(e);
			System.exit(1);
		}

	}
	
	public void callVariants(){
		
		String sam = parsedArgs.getString("SAM");
		String vcf = parsedArgs.getString("VCF");
		String sampleRef = parsedArgs.getString("REF");
		String hgRef = parsedArgs.getString("HG_REF");

		int minSVSize = parsedArgs.getInt("MIN_SIZE");
		int minMapQual = parsedArgs.getInt("MinMapQual");
		int minDepth = parsedArgs.getInt("MinDepth");
		int expectedCoverage = parsedArgs.getInt("ExpectedCoverage");
		int maxClip = parsedArgs.getInt("CLIP");
		String stringency = parsedArgs.getString("STRINGENCY");
		ValidationStringency vs = null;
		
		if("strict".equalsIgnoreCase(stringency)){
			vs = ValidationStringency.STRICT;
		}
		else if("lenient".equalsIgnoreCase(stringency)){
			vs = ValidationStringency.LENIENT;
		}
		else if("silent".equalsIgnoreCase(stringency)){
			vs = ValidationStringency.SILENT;
		}
		
		try {

			/* Calculate the max acceptable coverage. What proportion
			 * above expected coverage is excessive?
			 */
			double maxProportion = 1.5;
			int maxAcceptableCoverage =
					new Double(expectedCoverage * maxProportion).intValue();

			// Do your thing.
			StructuralVariantCaller svc = new StructuralVariantCaller(new File(sam),
					new File(vcf), new File(sampleRef), new File(hgRef),
					minSVSize, minMapQual, minDepth, maxAcceptableCoverage, 
					maxClip, vs);

			svc.startWalkingByLocus();

		} catch (FileNotFoundException e) {
			UtilityBelt.printErrorUsageHelpAndExit(parser, logger, e);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

//		try {
//			svc.startWalking();
//		} catch (StructuralVariantCallerException e) {
//			UtilityBelt.printErrorUsageHelpAndExit(parser, logger, e);
//		} catch (FileNotFoundException e) {
//			UtilityBelt.printErrorUsageHelpAndExit(parser, logger, e);
//		} catch(IOException e){
//			UtilityBelt.printErrorUsageHelpAndExit(parser, logger, e);
//		} catch (Exception e){
//			logger.error("Caught unexpected exception, something is very wrong!");
//			e.printStackTrace();
//		}

	}

}
