/**
 * 
 */
package spike.tools.referencesegmentgenerator;

import net.sourceforge.argparse4j.ArgumentParsers;
import net.sourceforge.argparse4j.inf.ArgumentGroup;
import net.sourceforge.argparse4j.inf.ArgumentParser;
import net.sourceforge.argparse4j.inf.ArgumentParserException;
import net.sourceforge.argparse4j.inf.MutuallyExclusiveGroup;
import net.sourceforge.argparse4j.inf.Namespace;

import org.apache.log4j.Logger;

import spike.Engine;

/**
 * @author markebbert
 *
 */
public class ReferenceSegmentGeneratorEngine implements Engine {

	private static Logger logger = Logger.getLogger(ReferenceSegmentGeneratorEngine.class);
	private static ArgumentParser parser;
	private Namespace parsedArgs;
	
	public ReferenceSegmentGeneratorEngine(String[] args){
		init(args);
	}
	
	private void init(String[] args){
		
		parser = ArgumentParsers.newArgumentParser("ReferenceSegmentGeneratorEngine");
		parser.description("The Reference Segement Generator will chop up the"
				+ " reference genome into segments (\'reads\') that are"
				+ " optimized by length for each region to maximize alignment"
				+ " specificity. Unique regions (e.g., exons) will not need"
				+ " very long reads, but other areas (e.g., repeat regions)"
				+ " will.");
		parser.defaultHelp(true);
		
		ArgumentGroup ioOptions = parser.addArgumentGroup("input/output arguments");
		MutuallyExclusiveGroup intermediateOptions = parser.addMutuallyExclusiveGroup("Intermediate starting points");
		ArgumentGroup rsgOptions = parser.addArgumentGroup("Reference Segment Generator arguments");

		/* Setup IO options */
		ioOptions
				.addArgument("-i", "--input")
				.dest("FASTA")
				.type(String.class)
				.required(true)
				.help("The reference genome in FASTA format. Or, if it has"
						+ " already been chopped up into FASTQ, we will optimize"
						+ " the existing reads. Must also have an associated"
						+ " '.dict' file as generated by Picard's "
						+ " CreateSequenceDictionary.jar");
		
		ioOptions
				.addArgument("-o", "--output")
				.dest("FASTQ_OUT")
				.type(String.class)
				.required(true)
				.help("The output FASTQ file for optimized reference segments.");

		intermediateOptions
				.addArgument("-q", "--fastq")
				.dest("FASTQ_IN")
				.type(String.class)
				.required(false)
				.help("The reference genome in FASTQ format. Use this option"
						+ " if it has already been chopped up into FASTQ. We"
						+ " will optimize the existing reads. NOTE: The FASTQ"
						+ " read names must be formatted as"
						+ " \'<contig_name>[<beginning_pos>-<end_pos>]\'");
		
		intermediateOptions
				.addArgument("-s", "--sam-file")
				.dest("SAM")
				.metavar("SAM/BAM")
				.type(String.class)
				.required(true)
				.help("A SAM/BAM file where reference segments have already been"
						+ " aligned to the reference genome.");

		
		rsgOptions
				.addArgument("-l", "--segment-length")
				.dest("LENGTH")
				.type(Integer.class)
				.setDefault(200)
				.help("The standard reference segment length to start with."
						+ " Reference segments will only be extended if they"
						+ " do not satisfy aligment criteria.");
		
		rsgOptions
				.addArgument("-m", "--mapq")
				.dest("MAPQ")
				.type(Integer.class)
				.setDefault(50)
				.help("The MAPQ threshold. If the segment does not have a MAPQ"
						+ " >= 50, and it's length is < MAX_LENGTH, extend it.");
		
		rsgOptions
				.addArgument("-n","--increment-by")
				.dest("INCREMENT")
				.type(Integer.class)
				.setDefault(50)
				.help("The number of nucleotides to increment by in each"
						+ " iteration.");

		rsgOptions
				.addArgument("-x", "--max-length")
				.dest("MAX_LENGTH")
				.type(Integer.class)
				.setDefault(500)
				.help("The maximum length any reference segment can be.");
	
		
		try{
			parsedArgs = parser.parseArgs(args);
		} catch (ArgumentParserException e){
			parser.handleError(e);
			System.exit(1);
		}
	}
	

	public void generateSegments() {
		String fasta = parsedArgs.getString("FASTA");
		String fastqIn = parsedArgs.getString("FASTQ_IN");
		String samBam = parsedArgs.getString("SAM");
		String fastqOut = parsedArgs.getString("FASTQ_OUT");
		
		int segLength = parsedArgs.getInt("LENGTH");
		int mapq = parsedArgs.getInt("MAPQ");
		int increment = parsedArgs.getInt("INCREMENT");
		int maxLength = parsedArgs.getInt("MAX_LENGTH");
		
//		ReferenceSegmentGenerator rsg = new ReferenceSegmentGenerator(fastqOut);
		if(fastqIn != null || samBam != null){
			// start with the fastq and optimize only
//			rsg.optimize(fastqIn, mapq, increment, maxLength);
		}
		else{
			// start from the beginning
//			rsg.generate();
		}
	}

}
